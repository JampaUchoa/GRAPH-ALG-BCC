#include "GRAPH_ADJ.h"
#include <stdlib.h>
#include <stdio.h>

/* REPRESENTA��O POR MATRIZ DE ADJAC�NCIAS: A fun��o GRAPHinit() constr�i um grafo com v�rtices 0 1 .. V-1 e nenhum arco. */
Graph GRAPHinit( int V) {
   Graph G = malloc( sizeof *G);
   G->V = V;
   G->A = 0;
   G->adj = MATRIXint( V, V, 0);
   return G;
}
/* REPRESENTA��O POR MATRIZ DE ADJAC�NCIAS: A fun��o MATRIXint() aloca uma matriz com linhas 0..r-1 e colunas 0..c-1. Cada elemento da matriz recebe valor val. */
static int **MATRIXint( int r, int c, int val) {
   int **m = malloc( r * sizeof (int *));
   for (vertex i = 0; i < r; ++i)
      m[i] = malloc( c * sizeof (int));
   for (vertex i = 0; i < r; ++i)
      for (vertex j = 0; j < c; ++j)
         m[i][j] = val;
   return m;
}
/* REPRESENTA��O POR MATRIZ DE ADJAC�NCIAS: A fun��o GRAPHinsertArc() insere um arco v-w no grafo G. A fun��o sup�e que v e w s�o distintos, positivos e menores que G->V. Se o grafo j� tem um arco v-w, a fun��o n�o faz nada. */
// Complexidade: O(1)
void GRAPHinsertArc( Graph G, vertex v, vertex w) {
   if (G->adj[v][w] == 0) {
      G->adj[v][w] = 1;
      G->A++;
   }
}
/* REPRESENTA��O POR MATRIZ DE ADJAC�NCIAS: A fun��o GRAPHremoveArc() remove do grafo G o arco v-w. A fun��o sup�e que v e w s�o distintos, positivos e menores que G->V. Se n�o existe arco v-w, a fun��o n�o faz nada. */
// Complexidade: O(1)
void GRAPHremoveArc( Graph G, vertex v, vertex w) {
   if (G->adj[v][w] == 1) {
      G->adj[v][w] = 0;
      G->A--;
   }
}
/* REPRESENTA��O POR MATRIZ DE ADJAC�NCIAS: A fun��o GRAPHshow() imprime, para cada v�rtice v do grafo G, em uma linha, todos os v�rtices adjacentes a v. */
void GRAPHshow( Graph G) {
   for (vertex v = 0; v < G->V; ++v) {
      printf( "%2d:", v);
      for (vertex w = 0; w < G->V; ++w)
         if (G->adj[v][w] == 1)
            printf( " %2d", w);
      printf( "\n");
   }
}

// Recebe um grafo G.
// Calcule um vetor isSink[] indexado pelos
// vértices de G, que é tal que isSink[v] é
// true se e somente se v é um sorvedouro.
// O(n^2)
// (Exercício 1.1 de https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphdatastructs.html)
vertex *GRAPH_isSink(Graph G) {

   vertex *isSink = malloc(G->V * sizeof (int));

   for(vertex x = 0; x < G->V; x++)
      if(GRAPHoutdeg(G, x) == 0)
         isSink[x] = 1;
      else
         isSink[x] = 0;

   return isSink;

}

// Recebe um grafo G.
// Calcule um vetor isSource[] indexado pelos
// vértices de G, que é tal que isSource[v] é
// true se e somente se v é um fonte.
// O(n^2)
// (Exercício 1.1 de https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphdatastructs.html)
vertex *GRAPH_isSource(Graph G) {

   vertex *isSource = malloc(G->V * sizeof (int));

   for(vertex x = 0; x < G->V; x++)
      if(GRAPHindeg(G, x) == 0)
         isSource[x] = 1;
      else
         isSource[x] = 0;

   return isSource;

}

// Calcula o grau de saída de um vértice
// v de um grafo G
// Complexidade: O(n)
// (Exercício 1.2 de https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphdatastructs.html)
int GRAPHoutdeg(Graph G, vertex v) {

   vertex j;
   int d = 0;
   for(j = 0; j < G->V; j++)
      if(G->adj[v][j] == 1)
         d++;

   return d;

}

// Calcula o grau de entrada de um vértice
// v de um grafo G
// Complexidade: O(n)
// (Exercício 1.2 de https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphdatastructs.html)
int GRAPHindeg(Graph G, vertex v) {

   vertex j;
   int d = 0;
   for(j = 0; j < G->V; j++)
      if(G->adj[j][v] == 1)
         d++;

   return d;

}

// Testa se um vértice v de um grafo G é
// isolado.
// Complexidade: O(n)
// (Exercício 1.3 de https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphdatastructs.html)
int GRAPHisolated(Graph G, vertex v) {

  return (GRAPHindeg(G, v) == 0) && (GRAPHoutdeg(G, v) == 0);
}


// Recebe um grafo G e devolve um
// outro grafo que é o reverso de G.
// (Exercício 1.10 de https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphdatastructs.html)
// Complexidade: O(n^2)
Graph GRAPHreverse(Graph G) {

  Graph H = GRAPHinit(G->V);
  H->A = G->A;

  for(int j = 0; j < G->V; j++)
    for(int k = 0; k < G->V; k++)
      H->adj[j][k] = G->adj[k][j];


  return H;

}

// Testa se um grafo G é um torneio
// usando o Teorema Tavares-Uchoa:
// G com n vértices é torneio sse
// para todo vértice v, g+(v) + g-(v) = n - 1.
// Complexidade: O(n^2)
// (Exercício 1.12 de https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphdatastructs.html)
int isTournament(Graph G) {

  vertex v;

  for(v = 0; v < G->V; v++)
    if(GRAPHindeg(G, v) + GRAPHoutdeg(G, v) != G->V - 1)
      return 0;

  return 1;

}

// Testa se w é adjacente a v num graph G
// Complexidade: O(1)
// (Exercício 1.4 de https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphdatastructs.html)
int GRAPHisadj(Graph G, vertex v, vertex w) {
  return G->adj[v][w];
}

// Recebe um grafo G e devolve um novo grafo,
// representando o complemento de G
// Complexidade: O(n^2)
Graph GRAPHcomplement(Graph G) {

  Graph H = GRAPHinit(G->V);
  for(int i = 0; i < G->V; i++)
    for(int j = 0; j < G->V; j++)
      if((i != j) && !GRAPHisadj(G, i, j))
        GRAPHinsertArc(H, i, j);

  return H;

}